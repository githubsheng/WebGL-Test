/* vertex shader */
uniform vec3 ecHemishpereLightPosition; //light position in the view coordinate space.
uniform vec3 SkyColor;
uniform vec3 GroundColor;

uniform mat4 MVMatrix;
uniform mat4 MVPMatrix;
uniform mat3 NormalMatrix;

uniform float SpecularContribution;
uniform float DiffuseContribution;

attribute vec4 MCVertex;
attribute vec3 MCNormal;

const vec3 wcDirectionalLightPosition = vec3(-1, 1, 1);

vec3 computeHemisphereLightingColor(const in tnorm, const in lightDir){
    float costheta = dot(tnorm, lightDir);
    float a = costheta * 0.5 + 0.5;
    return mix(GroundColor, SkyColor, a);
}

vec3 computeDirectionalLight(const in tnorm, const in ecPosition, const in lightDir){
    float diffuse = max(dot(lightDir), 0.0);
    float specular = 0.0;

    if (diffuse > 0.0) {
        vec3 viewDir = normalize(-ecPosition);
        vec3 reflectDir = reflect(-lightDir, tnorm);
        specular = max(dot(reflectVec, viewVec), 0.0);
        specular = pow(specular, 16.0);
    }

    return DiffuseContribution * diffuse +  SpecularContribution * specular;
}



void main() {
    vec3 ecPosition = vec3(MVMatrix * MCVertex);
    vec3 tnorm = normalize(NormalMatrix * MCNormal);
    vec3 lightDir = normalize(ecHemishpereLightPosition - ecPosition);
    vec3 hemishpereLightingColor = computeHemisphereLightingColor(tnorm, ecPosition, lightDir);
    vec3 directionalLightingColor = computeDirectionalLight(tnorm, ecPosition, lightDir);
    

    gl_Position = MVPMatrix * MCVertex;
}

/* fragment shader */

precision mediump float;

vec3 materialColor = vec3(1, 1, 1);

varying vec3 HemishpereColor;

void main(){
    gl_FragColor = vec4(materialColor * HemishpereColor, 1.0);
}